---
title: Type Checking Geomlab
author: Ashok Menon
abstract: |
  Lorem Ipsum.
...

```{.haskell}
```

\section{Introduction}

Lorem Ipsum.

\section{Background}

\subsection{Source Language}

In this project we will be developing a type system for \textit{Geomlab}, a dynamically typed, strict functional programming language used primarily for teaching purposes. In order to maintain focus, we will concentrate on a subset of the language (Figure\ \ref{fig:geomlab-syntax}).

\begin{figure}[htbp]
  \caption{A subset of the \textit{Geomlab} language. (i) \textit{Comments} are surrounded by curly braces and may be nested. (ii) The formal parameters of functions may be \textit{matched} against patterns. (iii) \textit{Guards}: A case of a function is evaluated only if all parameters match their patterns \textit{and} the guard expression (after the \texttt{when}) evaluates to \texttt{true}. (iv) \textit{Anonymous functions} are preceded by the \texttt{function} keyword. (v) Consecutive sequences of numbers may be generated by \textit{ranges}. (vi) \textit{List comprehensions} can be used to combine mapping, filter, and concatenation operations. (vii) Operators may be partially applied by \textit{sectioning}: \texttt{(+10)} corresponds to \texttt{function (x) x + 10}.}\label{fig:geomlab-syntax}
  \input{aux/geomlab_syntax.tex}
\end{figure}

This subset omits unification patterns (where multiple variables must be bound to the same value), $n+k$ patterns (matching numbers $m\geq k$, and binding $n\triangleq m-k$) and hash tables, as support for these can easily be added to a type system without changing the underlying theory. We also omit mutable reference cells as their interaction with polymorphism is a thorny issue which requires careful handling. (A story for another time.)

\subsection{Parsing}

\begin{figure}[htbp]
  \caption{\textit{Geomlab} Abstract Syntax Tree. The structure of literals are shared between that of patterns and of expressions, and so has been factored out.}\label{fig:sugar_adt}
  \input{aux/sugar.tex}
\end{figure}

We parse programs into abstract syntax trees of the $\mathbf{Sugar}$ type (Figure\ \ref{fig:sugar_adt}) which is ideal for parsing due to its similarity in structure to \textit{Geomlab}'s syntax. But, many of the nodes in $\mathbf{Sugar}$ --- corresponding to syntactic sugar --- are, in a sense, "redundant" from a typechecker's perspective. These nodes are mechanically derivable from the composition of others in $\mathbf{Sugar}$, and so in turn, the definition of the typechecker at these "sugary" nodes is derivable from its definition at other nodes. We avoid repeating this logic by \textit{desugaring} the input.

\subsection{Desugaring}

Desugaring involves replacing sugar with extensionally equivalent expressions from a restricted subset of the source language. We represent the AST after desugaring with a new type (Figure\ \ref{fig:expr_adt}) to ensure at compile-time that after desugaring, no sugar exists in the AST.

\begin{figure}[htbp]
  \caption{Type for the desugared AST.}\label{fig:expr_adt}
  \input{aux/expr.tex}
\end{figure}

List comprehensions, ranges and operator sections have been removed, and case expressions have been decoupled from function definitions into their own node (and the related \texttt{FailE} and \texttt{FallThroughE}). We also lift the restriction that only identifiers may be applied as functions. Finally, whilst in the source language patterns could be nested arbitrarily deep, in $\mathbf{Expr}$, each case expression only matches one layer (to reclaim the previous functionality, case expressions themselves are nested).

The procedure $\textit{desugar} : \mathbf{Sugar} \to \mathbf{Expr}$ treats operator sections, ranges and list comprehensions as in \textit{Geomlab}'s compiler\ \cite{Geomlab}, by converting to applications of helper functions provided by the runtime (Figure\ \ref{fig:standard-defs}), whilst the algorithm for desugaring case expressions draws inspiration from Lennart Augustsson's paper\ \cite{Augustsson:1985:CPM:5280.5303} on the techniques used to compile pattern matching in \textit{LML}, a lazy variant of \textit{ML}.

\begin{figure}
  \caption{Helper functions, as found in \textit{Geomlab}'s compiler.}\label{fig:standard-defs}
  \input{aux/standard_defs.tex}
\end{figure}

\subsection{de-Bruijn Indices}

$\mathbf{Expr}$ also alters the way local variables are introduced and denoted, using a notation referred to as \textit{de Bruijn} indices. $\mathbf{Expr}$ AST nodes that introduce new variables (like function definitions, let and case expressions) do not declare variable names, but instead simply declare how many local variables they introduce (functions introduce one for each formal parameter, let expressions always introduce one, and case expressions introduce one for every hole in the pattern). Then a reference to a local variable is denoted by the number of scopes between the reference and the scope introducing it (Figure\ \ref{fig:de_bruijn}).

\begin{figure}[htbp]
  \caption{Desugaring local variables to de-Bruijn indices.}\label{fig:de_bruijn}
  \input{aux/de_bruijn.tex}
\end{figure}

This notation has several advantages:

\begin{itemize}
  \item It tackles the issue of name shadowing (from variables inserted by the desugarer) without resorting to generating unique symbols, which requires side effectful operations.

  \item As a corollary to the first point, this makes \textit{desugar} a pure, deterministic function, which is better for testing.

  \item As the typechecker traverses the AST, it must create fresh \textit{type} variables for each local variable it encounters. These type variables can be stored in a stack, from which they can be efficiently retrieved using the local variable's de Bruijn index.

  \item When debugging output from the desugarer, free variables and bound variables are easily distinguishable in the AST.
\end{itemize}

\subsection{Definitions}

Below are some basic definitions used when discussing type systems and their associated theory.

By convention, the lowercase roman alphabet denotes terms, $r,s,t,\ldots$ (and variables $x,y,z,\ldots$), the lowercase greek alphabet denotes types, $\rho,\sigma,\tau,\ldots$ (and type variables, $\alpha,\beta,\gamma,\ldots$), and the uppercase greek alphabet denotes type contexts, $\Gamma,\Delta,\ldots$

\begin{definition}[Type Context]
  A context $\Gamma$ is a partial map from variables to types. Given a context $\Gamma$, variable $x$, and a type $\sigma$, we will write $\Gamma,x : \sigma$ to denote the map $\Gamma$ with its type for $x$ overwritten with $\sigma$.
\end{definition}

\begin{definition}[Type Judgement]
  $\Gamma\vdash t :\sigma$ is a type judgement stating that assuming context $\Gamma$ there exists a proof that $t$ inhabits type $\sigma$ (in some fixed type theory).
\end{definition}

\begin{definition}[Substitution]
  $\mathbb{S}\equiv[\tau_1/\alpha_1,\ldots,\tau_n/\alpha_n]\equiv[\tau_i/\alpha_i]$ is a type substitution that, when applied to a type $\sigma$ simultaneously replaces all free occurrences of $\alpha_i$ with $\tau_i$ in $\sigma$. Application of a substitution can be written as $\mathbb{S}(\sigma)$ or equivalently $\sigma[\tau_i/\alpha_i]$.

  Substitutions can also be applied to type contexts in which case they are applied to each type in the context in turn.

  We take $\varnothing$ to denote the identity substitution.
\end{definition}

\begin{definition}[Instance]
  A type $\sigma$ is said to be an instance of another type $\tau$ iff there exists a substitution $\mathbb{S}$ s.t. $\mathbb{S}(\tau)\equiv\sigma$.
\end{definition}

\begin{definition}[Principal Type]
  Given a term in our language $t$, we say that $t$ has principal type $A$ given type context $\Gamma$ when $\Gamma\vdash t : A$ and, for any other type $A^\prime$ and context $\Delta$ s.t. $\Delta\vdash t : A^\prime$ there exists a type substitution $\mathbb{S}$ satisfying $\Delta = \mathbb{S}(\Gamma)$ and $A^\prime = \mathbb{S}(A)$.
\end{definition}

Exactly what constitutes a type and what constitutes a deduction of a type judgement differs between type theories, but the above definitions always apply.

\section{Hindley and Milner's Type System}

We begin our search with the Hindley-Milner (henceforth HM) type system\ \cite{10.2307/1995158}\ \cite{MILNER1978348}. This theory forms the basis of many production quality type systems, including those found in \textit{Haskell} and the \textit{ML} family of languages.

HM builds on the types in the simply-typed $\lambda$ calculus by introducing \textit{universally quantified} variables in prenex form ($\forall\alpha_1\ldots\alpha_n\ldotp\tau$, where $\tau$ is quantifier free). This allows us to describe the types of polymorphic functions. For example, the identity function \texttt{define id(x) = x;} has principal type $\forall\alpha\ldotp\alpha\to\alpha$.

This type theory is a good starting point for many reasons: It has a reasonably efficient inference algorithm which has been proven sound and complete w.r.t the type system, the ability to specify polymorphic types affords a greater degree of flexibility, and given only a term, it is possible to infer its most general (principal) type. The last point is of particular import to us because our underlying language was originally dynamically typed, so there is no facility in the syntax to provide type annotations.

\subsection{Algorithm}

A clear exposition of a type inference algorithm for HM, Algorithm $\mathcal{W}$, is given in\ \cite{damas1982principal}, wherein it is described operating on $\lambda$ terms augmented with \texttt{let} bindings. Given a context $\Gamma$, and a term $t$, the algorithm returns a substitution $\mathbb{S}$ and type $\tau$ such that $\mathbb{S}(\Gamma)\vdash t:\tau$ is a principal deduction of $t$, if such a deduction exists (i.e. If $t$ is typeable).

We extend it further, to deal with literals, recursion, sequencing, conditionals, and case expressions to create an inference algorithm for our desugared subset of \textit{Geomlab} (For convenience, we adopt a textual syntax for ASTs of type $\mathbf{Expr}$):

$(\mathbb{S},\tau)\gets\mathcal{W}(\Gamma\vdash t)$ where
\begin{enumerate}[(i)]
  \item
    \begin{enumerate}[(a)]
      \item $t$ a number, string or atom literal\hfill{\scriptsize(literal)}
        \\[.5em] $\mathbb{S}\equiv\varnothing$ and $\tau\equiv\mathbf{number}$, $\mathbf{string}$, $\mathbf{atom}$ respectively.

      \item $t\equiv[]$: $\mathbb{S}\equiv\varnothing$ and $\tau\equiv[\alpha]$ ($\alpha$ fresh).\hfill{\scriptsize(nil)}

      \item $t\equiv (h:t)$\hfill{\scriptsize(cons)}
        \\[.5em] \begin{math}
          \arraycolsep=1.5pt
          \begin{array}{llll}
            \text{let} & (\mathbb{S}_1,\tau^\prime_1) & \gets & \mathcal{W}(\Gamma\vdash h)
            \\ & (\mathbb{S}_2,\tau^\prime_2) & \gets & \mathcal{W}(\mathbb{S}_1(\Gamma)\vdash t)
            \\ & \phantom{(}\mathbb{U} & \gets & \mathcal{U}(\tau^\prime_2,[\mathbb{S}_2(\tau^\prime_1)])
          \end{array}
        \end{math}
      \\[.5em] $\mathbb{S}\equiv\mathbb{US}_2\mathbb{S}_1$ and $\tau\equiv\mathbb{U}(\tau^\prime_2)$
    \end{enumerate}

  \item $t\equiv x\land x:\forall\alpha_1\ldots\alpha_n\ldotp\tau^\prime\in\Gamma$\hfill{\scriptsize(variables)}
    \\[.5em] $\mathbb{S}\equiv\varnothing$ and $\tau\equiv\tau^\prime[\beta_i/\alpha_i]$ ($\beta_i$ fresh).

  \item $t\equiv f(e_1,\ldots,e_k)$\hfill{\scriptsize(function applications)}
    \\[.5em] \begin{math}
      \arraycolsep=1.5pt
      \begin{array}{llll}
        \text{let} & (\mathbb{S}_0,\tau^\prime_0) & \gets & \mathcal{W}(\Gamma\vdash f)
        \\ & (\mathbb{S}_i,\tau^\prime_i) & \gets & \mathcal{W}(\mathbb{S}_{i-1}\ldots\mathbb{S}_{0}(\Gamma)\vdash e_i)
        \\ & \phantom{(}\mathbb{U} & \gets & \mathcal{U}(\mathbb{S}_k\ldots\mathbb{S}_1(\tau^\prime_0), (\tau^\prime_1,\ldots,\tau^\prime_k)\to\beta) \text{ ($\beta$ fresh)}
      \end{array}
    \end{math}
    \\[.5em] $\mathbb{S}\equiv\mathbb{U}\mathbb{S}_k\ldots\mathbb{S}_0$ and $\tau\equiv\mathbb{U}(\beta)$.

  \item $t\equiv \texttt{function ($x_1,\ldots,x_k$) $e$}$\hfill{\scriptsize(abstractions)}
    \\[.5em] let $(\mathbb{S}^\prime,\tau^\prime)\gets\mathcal{W}(\Gamma,x_1:\beta_1,\ldots,x_k:\beta_k\vdash e)$ ($\beta_i$ fresh)
    \\[.5em] $\mathbb{S}\equiv\mathbb{S}^\prime$ and $\tau\equiv(\mathbb{S}^\prime(x_1),\ldots,\mathbb{S}^\prime(x_k))\to\tau^\prime$

  \item $t\equiv \texttt{let $x$ = $e_1$ in $e_2$}$\hfill{\scriptsize(\textit{recursive} let expressions)}
    \\[.5em] \begin{math}
    \arraycolsep=1.5pt
    \begin{array}{llll}
      \text{let} & (\mathbb{S}_1,\tau_1) & \gets & \mathcal{W}(\Gamma,x:\beta\vdash e_1) \text{ ($\beta$ fresh)}
      \\ & \phantom{(}\mathbb{U} & \gets & \mathcal{U}(\mathbb{S}_1(\beta), \tau_1)
      \\ & \phantom{(}\Gamma^\prime,~\tau^\prime_1 & \gets & \mathbb{US}_1(\Gamma),~\mathbb{U}(\tau_1)
      \\ & (\mathbb{S}_2, \tau_2) & \gets & \mathcal{W}(\Gamma^\prime,x:\overline{\Gamma^\prime}(\tau^\prime_1)\vdash e_2)
    \end{array}
    \end{math}
    \\[.5em] $\mathbb{S}\equiv\mathbb{S}_2\mathbb{US}_1$ and $\tau\equiv\tau_2$

  \item $t\equiv e_1~\texttt{>>}~e_2$\hfill{\scriptsize(sequencing)}
    \\[.5em] \begin{math}
    \arraycolsep=1.5pt
    \begin{array}{llll}
      \text{let} & (\mathbb{S}_1,\tau_1) & \gets & \mathcal{W}(\Gamma\vdash e_1)
      \\ & (\mathbb{S}_2, \tau_2) & \gets & \mathcal{W}(\mathbb{S}_1(\Gamma)\vdash e_2)
    \end{array}
    \end{math}
    \\[.5em] $\mathbb{S}\equiv\mathbb{S}_2$ and $\tau\equiv\tau_2$.

  \item $t\equiv \texttt{if $b$ then $t$ else $e$}$\hfill{\scriptsize(conditionals)}
    \\[.5em] \begin{math}
    \arraycolsep=1.5pt
    \begin{array}{llll}
      \text{let} & (\mathbb{S}_1,\tau_1) & \gets & \mathcal{W}(\Gamma\vdash b)
      \\ & (\mathbb{S}_2, \tau_2) & \gets & \mathcal{W}(\mathbb{S}_1(\Gamma)\vdash t)
      \\ & (\mathbb{S}_3, \tau_3) & \gets & \mathcal{W}(\mathbb{S}_2\mathbb{S}_1(\Gamma)\vdash e)
      \\ & \phantom{(} \mathbb{U}_1 & \gets & \mathcal{U}(\mathbb{S}_3\mathbb{S}_2(\tau_1),\mathbf{bool})
      \\ & \phantom{(} \mathbb{U}_2 & \gets & \mathcal{U}(\mathbb{U}_1\mathbb{S}_3\mathbb{S}_2(\tau_2), \mathbb{U}_1\mathbb{S}_3\mathbb{S}_2(\tau_3))
    \end{array}
    \end{math}
    \\[.5em] $\mathbb{S}\equiv\mathbb{U}_2\mathbb{U}_1\mathbb{S}_3\mathbb{S}_2\mathbb{S}_1$ and $\tau\equiv\mathbb{U}_2\mathbb{U}_1\mathbb{S}_3\mathbb{S}_2(\tau_2)$.

  \item $t\equiv \texttt{case $c$ of } pat_1\to e_1;\cdots pat_k\to e_k;$\hfill{\scriptsize(case expressions)}
    \\[.5em] \begin{math}
    \arraycolsep=1.5pt
    \begin{array}{llll}
      \text{let} & (\mathbb{S}_0,\tau_0) & \gets & \mathcal{W}(\Gamma\vdash c)
      \\ & (\mathbb{S}_i, \tau_i) & \gets & \mathcal{P}(pat_i, e_i)\text{ where }
    \end{array}
    \end{math}
    \begin{enumerate}[(a)]
    \item $pat_i$ a numeric, string or atom literal pattern\hfill{\scriptsize(literal pattern)}
      \\[.2em] \begin{math}
        \arraycolsep=1.5pt
        \begin{array}{llll}
          \text{let} & \mathbb{U} & \gets & \mathcal{U}(\tau_0,\mathbf{number})\text{ ($\mathbf{string}$, $\mathbf{atom}$ respectively)}
          \\ & (\mathbb{S}^\prime,\tau^\prime) & \gets & \mathcal{W}(\mathbb{U}(\Gamma)\vdash e_i)
        \end{array}
      \end{math}
      \\[.2em] $\mathbb{S}_i\equiv\mathbb{S}^\prime\mathbb{U}$ and $\tau_i\equiv\tau^\prime$

    \item $pat_i\equiv[]$\hfill{\scriptsize(nil pattern)}
      \\[.2em] \begin{math}
        \arraycolsep=1.5pt
        \begin{array}{llll}
          \text{let} & \mathbb{U} & \gets & \mathcal{U}(\tau_0,[\alpha])\text{ ($\alpha$ fresh) }
          \\ & (\mathbb{S}^\prime,\tau^\prime) & \gets & \mathcal{W}(\mathbb{U}(\Gamma)\vdash e_i)
        \end{array}
      \end{math}
      \\[.2em] $\mathbb{S}_i\equiv\mathbb{S}^\prime\mathbb{U}$ and $\tau_i\equiv\tau^\prime$

    \item $pat_i\equiv(h:t)$\hfill{\scriptsize(cons pattern)}
      \\[.2em] \begin{math}
        \arraycolsep=1.5pt
        \begin{array}{llll}
          \text{let} & \mathbb{U} & \gets & \mathcal{U}(\tau_0,[\alpha])\text{ ($\alpha$ fresh)}
          \\ & (\mathbb{S}^\prime,\tau^\prime) & \gets & \mathcal{W}(\mathbb{U}(\Gamma),h:\alpha,t:[\alpha]\vdash e_i)
        \end{array}
      \end{math}
      \\[.2em] $\mathbb{S}_i\equiv\mathbb{S}^\prime\mathbb{U}$ and $\tau_i\equiv\tau^\prime$
    \end{enumerate}
\end{enumerate}

\subsection{Implementation}

Lorem Ipsum.

\subsection{Applications}

Lorem Ipsum.

\subsection{Limitations}

Lorem Ipsum.

\section{Regular Tree Grammars}

Lorem Ipsum.

\section{Variance}

Lorem Ipsum.

\section{Type Errors}

Lorem Ipsum.

\section{References}

\bibliography{references}
